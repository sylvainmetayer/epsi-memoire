\todo[color=yellow]{Automatiser un projet, 12 pages mini}

\subsection{Management, gestion de projet \& planification sont sur un bateau}

\todo[color=yellow]{Partie management, comment gérer un changement ?, 3 pages}

\epigraph{\frquote{Neuf femmes ne font pas un enfant en un mois}}{\citetitle{manmonth} - \citeauthor{manmonth} \cite{manmonth}}

L'automatisation d'un projet ne peut s'effectuer un en jour. De même que la citation ci-dessus fait sens, il n'est pas possible de migrer un projet existant en une journée vers une automatisation totale. Il est donc nécessaire de préparer et planifier une conduite du changement qui permettra d'accompagner tous les acteurs du projet, afin que la transition s'effectue dans les meilleurs conditions possible. Cela passe d'abord par une réflexion sur la conduite à adopter et les changements à apporter. 

Prenons pour exemple un projet fonctionnel depuis maintenant plusieurs mois. Le projet a déjà été livré (avec plus ou moins de difficulté) quelques fois en production. Comment convaincre que l'automatisation va apporter du bien à ce projet ? Qui est-il nécessaire de convaincre ?

Tout d'abord, il faut convaincre les personnes responsables financièrement du projet. En effet, il est possible d'avoir un projet automatisé de A à Z, si ce processus d'automatisation vient à coûter 3 fois le prix total vendu au client, aucun responsable ne vous donnera son accord. Il va également falloir convaincre les personnes responsables du projet (chef de projet, directeur de projet...) qu'il y a un intérêt à effectuer cela. En effet, sans garantie que ce processus pourra amener quelque chose de positif, peu laisseront une opportunité d'essayer d'automatiser un projet.


Il faut ainsi préparer son argumentaire, avec les bienfaits que cela pourra obtenir sur les \gls{KPI} et sur la vie du projet à moyen/long terme.

\begin{itemize}
	\item \todo[color=red]{Listes de KPI intéressant avec deux trois mots sur chaque.}
\end{itemize}

Il est également nécessaire de planifier au mieux les durées des travaux à accomplir afin d'éviter des dépassements dans les délais annoncés. Cela implique donc de réfléchir au temps nécessaire à investir et aux différents jalons qui valideront la bonne mise en place de l'automatisation. 

Pour pouvoir mettre en place une démarche d'automatisation sur un projet, il est nécessaire que ce dernier soit assez mature pour pouvoir s'y adapter. Ainsi, comme l'indique \citetitle{phoenixProject} \cite{phoenixProject},  avant de se lancer dans une démarche d'automatisation (\emph{ou plus globalement, pour pouvoir gérer correctement un projet}), la première étape est de savoir gérer le flux de travail.

Le flux de travail, ce sont les différentes tâches qui sont à réaliser sur le projet. Ces dernières sont souvent des stories, définies conjointement avec le client et correspondent ainsi à ce qui a été défini dans le cahier des charges. L'inconvénient est que ce flux de travail est fragile. Il peut rapidement dériver et se retrouver surcharger, surchargeant ainsi les équipes. Le principal ennemi de flux de travail est le travail non prévu (\emph{unplanned work}). Ce sont toutes les petites tâches non prévues, qui prennent 10 à 15 minutes, qui ne sont suivies nulle part et qui mises bout à bout peuvent faire perdre plusieurs jours de travail et épuiser les équipes, qui ne voit jamais le travail diminuer.

Quelles sont donc les solutions pour gérer ce travail non prévu ? L'objectif est ici de faire en ce sorte que ce travail non prévu ne soit plus exécuté directement sans passer par une phase minimale de planification. Pour cela, il est possible de mettre en place des kanbans. Qu'est ce qu'un Kanban ? Il s'agit d'une méthode de représentation des tâches qui permet de visualiser l'avancée du projet en temps réel (\emph{ou du moins, à chaque fois que le tableau est mis à jour}). 

\newImage{0.35}{kanban.jpg}{Représentation d'un tableau Kanban -  \url{https://commons.wikimedia.org/}}{kanban}

On peut constater sur la figure \ref{fig:kanban} que l'on peut limiter le travail non prévu, en l'ajoutant à une catégorie, le \emph{backlog}, qui correspond à la pile de tâche à réaliser. Une fois ces tâches estimées, découpées et discutées avec le client, elles peuvent être considérées comme prête à être commencées. On peut ensuite suivre l'évolution des tâches dans leur différentes étapes, du développement à leur livraison, en passant par les tests. Ainsi, le travail non prévu ne peut plus déranger un sprint en cours puisqu'il est possible de définir des limites, en disant par exemple que seules les tâches étant prêtes seront travaillées dans ce sprint et que les autres devront attendre le prochain sprint pour pouvoir être traitées. Néanmoins, il s'agit de faire attention à un point en mettant en place un kanban. En effet, si l'on met simplement en place un kanban et que l'on continue de traiter les tâches comme elles l'étaient précédemment, on s'expose au risque de voir le travail en cours, ou \emph{WIP\footnote{Work In Progress}} s'accumuler. Cela risque donc de ralentir les équipes voir de les démotiver. De plus, si tous le travail est en WIP, il n'y a aucune façon de savoir depuis combien de temps un tâche est présente ici, ce qui fait que certaines tâches peuvent très bien rester en WIP pendant des jours voir des semaines. La solution à ce problème tient dans le fait de limiter le travail en cours. En effet, en limitant le travail en cours, on s'assure que les tâches ne resteront pas éternellement en attente. Les tâches bloquées pourront éventuellement être passées dans une colonne "Bloqué"\footnote{Cette colonne devra elle aussi être limitée en éléments, sous peine de seulement décaler le soucis !}. De plus, si le travail en cours est restreint, il sera de meilleur qualité, puisque moins dispersé et donc engendrera moins de bug !

L'un des objectifs de l'automatisation est également de faciliter le passage d'un système ou l'on met plusieurs mois avant de livrer une grosse fonctionnalité à un ou l'on livre de multiples petites fonctionnalités. Attendre plusieurs mois pour livrer une fonctionnalité peut en effet avoir des effets indésirables.

\begin{itemize}
	\item Dans une époque où l'on veut tout, toujours plus vite, certains besoins sont éphémères. Si l'on livre la fonctionnalité une fois le besoin passé, la fonctionnalité n'a plus de sens. Il vaut mieux livrer petit à petit des parties de cette fonctionnalité pour pouvoir l'améliorer continuellement.
	\item Une fonctionnalité qui met longtemps à être livré induira un stress au niveau des équipes, qui auront sur leurs épaules la responsabilité de livrer \emph{la fonctionnalité parfaite}, plutôt que livrer plusieurs petites fonctionnalités
	\item Le risque d'échec est beaucoup plus important en livrant une fonctionnalité plutôt que plusieurs petites, surtout si des changements d'architecture (\emph{Structure de la base de données, ajout de nouveaux composants...})
	\item \todo[color=red]{Chercher d'autres idées indésirables pour ne pas mettre en place de l'amélioration continue.}
\end{itemize}

Cette volonté de vouloir livrer plus petit mais plus régulièrement s'inscrit dans \emph{l'amélioration continue}. Au début, la fonctionnalité ne sera peut-être pas parfaite, mais elle sera continuellement améliorée jusqu'à correspondre au besoin voulu.

Néanmoins, il convient de vérifier que ce système est intégré et accepté par l'équipe, sous peine de voir un rejet de cette méthodologie et d'entrainer des conflits internes dans les équipes. Cela peut être le cas avec certaines personnes réfractaires au changement, par exemple des développeurs âgés, proche de le retraite, qui n'ont peut-être pas envie de se reformer et s'adapter à de nouvelles méthodes de travail et qui tenteront de garder leurs habitudes. Cela peut également provenir de personnalités avec un fort caractère qui pensent que leur méthode est plus efficace que les autres ou encore de bien d'autres cas. De manière générale, les personnes ne souhaitent pas sortir de leur zone de confort. Pour permettre ce changement, il va falloir exposer les différents avantages aux équipes et leur montrer les intérêts qu'ils ont à s'essayer à cette méthode pour peut-être finir par l'adopter de leur plein gré.

L'un des premiers avantages si l'on met en place une démarche d'automatisation est une meilleure communication entre les développeurs, également appelés \emph{Dev}, et les administrateurs des infrastructures, administrant et déployant les applications, appelés \emph{Ops}. Si l'on met en place une démarche d'automatisation, un besoin de métrique va être nécessaire. Ces métriques, semblables aux \gls{KPI} précédemment détaillés, permettront de savoir par exemple le temps de déploiement de l'application, les derniers bugs remontés, les suivis de performance afin de déterminer si une requête \gls{SQL} est trop lente ou non... Ces métriques, conjointement définies par les \emph{Devs} et les \emph{Ops} va permettre d'obtenir des retours rapides et ainsi de pouvoir améliorer le produit plus facilement, en corrigeant les bugs au plus tôt. C'est la base de la \emph{Second Way}, ou deuxième étape, comme détaillé dans \citetitle{phoenixProject} \cite{phoenixProject} \todo[color=orange]{Faire valider cette partie sur le feedback}.

\todo[color=cyan]{Terminer partie management automatisation.}

- Third Way : Apprentissage continu. Prévoir du temps pour améliorer l'environnement de travail, les déploiements  \& co.

- Partage de connaissance, pour construire une équipe qui puisse s'adapter.

\subsection{Localement, lors des phases de développement}

\todo[color=cyan]{Localement, lors des phases de développement, 2 pages}

Permettre un démarrage rapide pour pouvoir se concentrer sur une fonctionnalité plutôt que sur le "ça marche pas parce que tu n’as pas installé ça". => Valeur ajoutée, performance, productivité

But : prévenir l'erreur avant qu'elle ne quitte le poste du développeur (et soit donc sur le dépôt Git).

-  Linter

-  Docker, stack reproductible et indépendante selon environnement (windows/linux/mac) 

- IDE à configurer, éventuellement partager la configuration (ex: PHP Storm Code Style)

-  Makefile / scripts shell de taches récurrentes (cache clear, installation...)

- Git hook pour vérifier que tout est OK.

% https://dev.to/shameemreza/3-tricks-to-automate-development-tasks-with-git-hooks-2dah

\subsection{L'importance des tests} \label{importance-test}

\todo[color=cyan]{Importance des tests, 1-2 pages}


- Résilience de l'application, tester sous différents angles continuellement afin de vérifier qu'elle se comporte correctement.

Tout l'automatisation ne sert à rien sans une bonne campagne de tests, fonctionnel, unitaire, d'intégration, E2E...

Parler de Protractor et Squash sur \bv. Tests automatisés unitaires (phpunit) permettant à la plateforme d'intégration continue de vérifier la conformité du code par rapport aux attentes métiers.

différence entre intégration continue et tests unitaires (image du lavabo + séchoir à main côte à côte). Les tests unitaires vont tester la cohérence d'une partie du système tandis que l'intégration va tester la cohérence de l'échange entre divers systèmes / fonctions.

rapidité des tests à une importance pour un retour rapide aux dev

parler des différents type de test, en détaillant un peu le fonctionnement et l'utilité de chacun.
\subsection{Intégration et déploiement continu}

\todo[color=cyan]{Intégration de déploiement continu, 3-4 pages}

Retour le plus rapide possible pour éviter des bugs en prod. 

Le reporting de bug automatique (sentry.io)

Intégration des tests dans jenkins

Monitoring : monit pour monitorer l'état d'application ? (perso)

Jenkins, Travis, Déployer automatiquement à partir d'un push sur dev, en recette, intégration, staging, et lorsque tout passe, en production.

Infra As Code % https://dev.to/klauenboesch/why-use-infrastructure-as-a-code-3793

\textit{Exemple : parler de NAQ Automatisation de la création de la base de données et de la restauration des données}

Feature flipping pour tester (A/B) et faire des rollback rapides.

Comment setup ? webhook (avec en annexe deux images, côté Jenkins avec le secret et côté Gitlab avec le secret)

\subsection{Et la sécurité dans tout ça ?}

\todo[color=cyan]{Sécurité, 1-2 page }

Gestion des tokens, gestion des comptes.
Un compte admin ou plusieurs sous compte avec des droits limités ? En cas d'intrusion, un attaquant a moins de chance de corrompre tout le système.
Infra : restriction d'accès (htaccess / firewall / ..?)

Vérifier les dépendances (failles, paquet npm corrompu...)

Attention à l'endroit ou sont fait les builds/tests. Il est préférable, pour des raisons de sécurité évidente d'utiliser un outil auto-hébergé, open source, plutôt que des outils clés en main, ou les données sont envoyées sur des serveurs inconnus. 

Dans certains cas, l'application ne doit pas quitter le périmètre de l'entreprise,il faut donc avoir la maitrise totale de la chaine d'industrialisation
